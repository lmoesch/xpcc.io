<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>xpcc: xpcc::BoundedDeque&lt; T, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xpcc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classxpcc_1_1_bounded_deque.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classxpcc_1_1_bounded_deque-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">xpcc::BoundedDeque&lt; T, N &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__container.html">Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Double ended queue.  
 <a href="classxpcc_1_1_bounded_deque.html#details">More...</a></p>

<p><code>#include &lt;xpcc/container/deque.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_bounded_deque_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional const iterator.  <a href="classxpcc_1_1_bounded_deque_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3e969ebeea58a20418145f6515c6eebc"><td class="memItemLeft" align="right" valign="top"><a id="a3e969ebeea58a20418145f6515c6eebc"></a>
typedef <a class="el" href="group__tmp.html#structxpcc_1_1tmp_1_1_select">xpcc::tmp::Select</a>&lt;(N &gt;=255), uint_fast16_t, uint_fast8_t &gt;::Result&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b></td></tr>
<tr class="separator:a3e969ebeea58a20418145f6515c6eebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd924a92b459c268385eab4c1658de7b"><td class="memItemLeft" align="right" valign="top"><a id="abd924a92b459c268385eab4c1658de7b"></a>
typedef Index&#160;</td><td class="memItemRight" valign="bottom"><b>Size</b></td></tr>
<tr class="separator:abd924a92b459c268385eab4c1658de7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac803e02511ed26bec9d801981b8d6888"><td class="memItemLeft" align="right" valign="top"><a id="ac803e02511ed26bec9d801981b8d6888"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEmpty</b> () const</td></tr>
<tr class="separator:ac803e02511ed26bec9d801981b8d6888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7fc97e0ef4e095ab99d4e92f40c611"><td class="memItemLeft" align="right" valign="top"><a id="a9f7fc97e0ef4e095ab99d4e92f40c611"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNotEmpty</b> () const</td></tr>
<tr class="separator:a9f7fc97e0ef4e095ab99d4e92f40c611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecea72517c30291afee40ee27635b6f4"><td class="memItemLeft" align="right" valign="top"><a id="aecea72517c30291afee40ee27635b6f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFull</b> () const</td></tr>
<tr class="separator:aecea72517c30291afee40ee27635b6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719854cad321913eb3d3bdb9c3c2f4b3"><td class="memItemLeft" align="right" valign="top"><a id="a719854cad321913eb3d3bdb9c3c2f4b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNotFull</b> () const</td></tr>
<tr class="separator:a719854cad321913eb3d3bdb9c3c2f4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c39ee16b4bc1a8f27689818b3d8487"><td class="memItemLeft" align="right" valign="top"><a id="a16c39ee16b4bc1a8f27689818b3d8487"></a>
Size&#160;</td><td class="memItemRight" valign="bottom"><b>getSize</b> () const</td></tr>
<tr class="separator:a16c39ee16b4bc1a8f27689818b3d8487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07c56d2f75de6535ffe97e3da7a1623"><td class="memItemLeft" align="right" valign="top"><a id="ad07c56d2f75de6535ffe97e3da7a1623"></a>
Size&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxSize</b> () const</td></tr>
<tr class="separator:ad07c56d2f75de6535ffe97e3da7a1623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa56fa09f5ab18a6c2eeda8e67173158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_bounded_deque.html#afa56fa09f5ab18a6c2eeda8e67173158">clear</a> ()</td></tr>
<tr class="memdesc:afa56fa09f5ab18a6c2eeda8e67173158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the container.  <a href="#afa56fa09f5ab18a6c2eeda8e67173158">More...</a><br /></td></tr>
<tr class="separator:afa56fa09f5ab18a6c2eeda8e67173158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab18cf0f608383b1a719849b77afb5f2"><td class="memItemLeft" align="right" valign="top"><a id="aab18cf0f608383b1a719849b77afb5f2"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getFront</b> ()</td></tr>
<tr class="separator:aab18cf0f608383b1a719849b77afb5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778b79fd9989de92c4e800b721ef2463"><td class="memItemLeft" align="right" valign="top"><a id="a778b79fd9989de92c4e800b721ef2463"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getFront</b> () const</td></tr>
<tr class="separator:a778b79fd9989de92c4e800b721ef2463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391333d995d96f0d7ec8ea9e90d6e49e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_bounded_deque.html#a391333d995d96f0d7ec8ea9e90d6e49e">get</a> (Index n)</td></tr>
<tr class="memdesc:a391333d995d96f0d7ec8ea9e90d6e49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item at specified index.  <a href="#a391333d995d96f0d7ec8ea9e90d6e49e">More...</a><br /></td></tr>
<tr class="separator:a391333d995d96f0d7ec8ea9e90d6e49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6c7cd0de763b1b720fe7c03eb795b1"><td class="memItemLeft" align="right" valign="top"><a id="aac6c7cd0de763b1b720fe7c03eb795b1"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> (Index n) const</td></tr>
<tr class="separator:aac6c7cd0de763b1b720fe7c03eb795b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b15bed4c9d6e3122e42cf45dd739ad6"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_bounded_deque.html#a6b15bed4c9d6e3122e42cf45dd739ad6">operator[]</a> (Index n)</td></tr>
<tr class="memdesc:a6b15bed4c9d6e3122e42cf45dd739ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item at specified index.  <a href="#a6b15bed4c9d6e3122e42cf45dd739ad6">More...</a><br /></td></tr>
<tr class="separator:a6b15bed4c9d6e3122e42cf45dd739ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa6c7ffc24ac16ef870dd348ad7120"><td class="memItemLeft" align="right" valign="top"><a id="a8aaa6c7ffc24ac16ef870dd348ad7120"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (Index n) const</td></tr>
<tr class="separator:a8aaa6c7ffc24ac16ef870dd348ad7120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b453454ee6c4b2c9780b20baa7c3fd"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_bounded_deque.html#a50b453454ee6c4b2c9780b20baa7c3fd">rget</a> (Index n)</td></tr>
<tr class="memdesc:a50b453454ee6c4b2c9780b20baa7c3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get item at specified index.  <a href="#a50b453454ee6c4b2c9780b20baa7c3fd">More...</a><br /></td></tr>
<tr class="separator:a50b453454ee6c4b2c9780b20baa7c3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcca58042c73c9a31a758e9e948dafc4"><td class="memItemLeft" align="right" valign="top"><a id="abcca58042c73c9a31a758e9e948dafc4"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>rget</b> (Index n) const</td></tr>
<tr class="separator:abcca58042c73c9a31a758e9e948dafc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3f619cc20de62b076eed645faab79c"><td class="memItemLeft" align="right" valign="top"><a id="a4e3f619cc20de62b076eed645faab79c"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getBack</b> ()</td></tr>
<tr class="separator:a4e3f619cc20de62b076eed645faab79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39ecedebe39c6c3c829caf556a4f569"><td class="memItemLeft" align="right" valign="top"><a id="ae39ecedebe39c6c3c829caf556a4f569"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getBack</b> () const</td></tr>
<tr class="separator:ae39ecedebe39c6c3c829caf556a4f569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf31a5b67ebc144acbbab00b33656d28"><td class="memItemLeft" align="right" valign="top"><a id="aaf31a5b67ebc144acbbab00b33656d28"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const T &amp;value)</td></tr>
<tr class="separator:aaf31a5b67ebc144acbbab00b33656d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec35598f10e247b96012986ac4b23d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_bounded_deque.html#acec35598f10e247b96012986ac4b23d9">appendOverwrite</a> (const T &amp;value)</td></tr>
<tr class="memdesc:acec35598f10e247b96012986ac4b23d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an item to the back of the deque overwriting existing items.  <a href="#acec35598f10e247b96012986ac4b23d9">More...</a><br /></td></tr>
<tr class="separator:acec35598f10e247b96012986ac4b23d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdeee12310fd76e45a03d107be2a2df"><td class="memItemLeft" align="right" valign="top"><a id="a4cdeee12310fd76e45a03d107be2a2df"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>prepend</b> (const T &amp;value)</td></tr>
<tr class="separator:a4cdeee12310fd76e45a03d107be2a2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53bf4356666807136a2b2fb2e39c9f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_bounded_deque.html#ad53bf4356666807136a2b2fb2e39c9f2">prependOverwrite</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ad53bf4356666807136a2b2fb2e39c9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an item to the front of the deque overwriting existing items.  <a href="#ad53bf4356666807136a2b2fb2e39c9f2">More...</a><br /></td></tr>
<tr class="separator:ad53bf4356666807136a2b2fb2e39c9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d63eacd20be99f69b11daf4d4f5603"><td class="memItemLeft" align="right" valign="top"><a id="aa6d63eacd20be99f69b11daf4d4f5603"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeBack</b> ()</td></tr>
<tr class="separator:aa6d63eacd20be99f69b11daf4d4f5603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46af3ea80511e3a027cd934f34907ed7"><td class="memItemLeft" align="right" valign="top"><a id="a46af3ea80511e3a027cd934f34907ed7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFront</b> ()</td></tr>
<tr class="separator:a46af3ea80511e3a027cd934f34907ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf6a1f292824200916b2689f9e063e5"><td class="memItemLeft" align="right" valign="top"><a id="aedf6a1f292824200916b2689f9e063e5"></a>
<a class="el" href="classxpcc_1_1_bounded_deque_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:aedf6a1f292824200916b2689f9e063e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2bbd1199bf45676b69bed08fa3edf2"><td class="memItemLeft" align="right" valign="top"><a id="aed2bbd1199bf45676b69bed08fa3edf2"></a>
<a class="el" href="classxpcc_1_1_bounded_deque_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:aed2bbd1199bf45676b69bed08fa3edf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t N&gt;<br />
class xpcc::BoundedDeque&lt; T, N &gt;</h3>

<p>Internally organized as a ring buffer.</p>
<pre class="fragment">*           tail --\                 /-- head
*                  |                 |
*        +------+------+---- ----+------+------+
*      0 |      | data |   ...   | data |      | N-1
*        +------+------+---- ----+------+------+
*           |      |                 |      |
* prepend --/      |                 |      \-- append
*                  |                 |
*       getFront --/                 \-- getBack
* </pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements </td></tr>
    <tr><td class="paramname">N</td><td>Size of the queue</td></tr>
  </table>
  </dd>
</dl>
<p>Up to a size of 254 small index variables with 8-bits are used, after this they are switched to 16-bit.</p>
<dl class="section warning"><dt>Warning</dt><dd>This class don't check if the container is empty before a pop-operation. You have to do this by yourself!</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Fabian Greif </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="afa56fa09f5ab18a6c2eeda8e67173158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa56fa09f5ab18a6c2eeda8e67173158">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxpcc_1_1_bounded_deque.html">xpcc::BoundedDeque</a>&lt; T, N &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This will discard all the items in the container </dd></dl>

</div>
</div>
<a id="a391333d995d96f0d7ec8ea9e90d6e49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391333d995d96f0d7ec8ea9e90d6e49e">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classxpcc_1_1_bounded_deque.html">xpcc::BoundedDeque</a>&lt; T, N &gt;::get </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the item at index <code>n</code>, counting 0-indexed from Front to Back, which is the same order in that the items were appended and the iterator addresses them.</p>
<dl class="section warning"><dt>Warning</dt><dd>Please make sure <code>n</code> is a valid index: 0 &lt;= <em>n</em> &lt; <em>size</em>. Other indexes will cause undefined behaviour. </dd></dl>

</div>
</div>
<a id="a6b15bed4c9d6e3122e42cf45dd739ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b15bed4c9d6e3122e42cf45dd739ad6">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classxpcc_1_1_bounded_deque.html">xpcc::BoundedDeque</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the item at index <code>n</code>, counting 0-indexed from Front to Back.</p>
<dl class="section warning"><dt>Warning</dt><dd>Please make sure <code>n</code> is a valid index: 0 &lt;= <em>n</em> &lt; <em>size</em>. Other indexes will cause undefined behaviour. </dd></dl>

</div>
</div>
<a id="a50b453454ee6c4b2c9780b20baa7c3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b453454ee6c4b2c9780b20baa7c3fd">&#9670;&nbsp;</a></span>rget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classxpcc_1_1_bounded_deque.html">xpcc::BoundedDeque</a>&lt; T, N &gt;::rget </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the item at index <code>n</code>. The items are indexed in reverse (Back to Front), which is their order when they have been prepended.</p>
<dl class="section warning"><dt>Warning</dt><dd>Please make sure <code>n</code> is a valid index: 0 &lt;= <em>n</em> &lt; <em>size</em>. Other indexes will cause undefined behaviour. </dd></dl>

</div>
</div>
<a id="acec35598f10e247b96012986ac4b23d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec35598f10e247b96012986ac4b23d9">&#9670;&nbsp;</a></span>appendOverwrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxpcc_1_1_bounded_deque.html">xpcc::BoundedDeque</a>&lt; T, N &gt;::appendOverwrite </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method, in contrast to <code>append()</code>, overwrites existing items in the deque if it is full. When an item is appended to the already full deque, the front item is removed to use its space for the new item, which is inserted after back. </p>

</div>
</div>
<a id="ad53bf4356666807136a2b2fb2e39c9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53bf4356666807136a2b2fb2e39c9f2">&#9670;&nbsp;</a></span>prependOverwrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxpcc_1_1_bounded_deque.html">xpcc::BoundedDeque</a>&lt; T, N &gt;::prependOverwrite </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method, in contrast to <code>prepend()</code>, overwrites existing items in the deque if it is full. When an item is prepended to the already full deque, the back item is removed to use its space for the new item, which is inserted at front. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deque.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacexpcc.html">xpcc</a></li><li class="navelem"><a class="el" href="classxpcc_1_1_bounded_deque.html">BoundedDeque</a></li>
    <li class="footer">Generated on Tue Jun 27 2017 20:03:52 for xpcc by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
